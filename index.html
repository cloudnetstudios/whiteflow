<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>whiteflow | online whiteboard</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>

    <style>

        /* Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: #f8faff;
    color: #333;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.container {
    max-width: 100%;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header Styles */
header {
    background-color: #ffffff;
    padding: 15px 25px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    z-index: 10;
}

.logo {
    font-size: 24px;
    font-weight: 600;
    color: #4a86e8;
    letter-spacing: -0.5px;
}

.mode-toggle {
    display: flex;
    align-items: center;
    gap: 10px;
}

.mode-btn {
    background-color: #f0f6ff;
    border: none;
    border-radius: 6px;
    padding: 8px 15px;
    font-family: 'Inter', sans-serif;
    font-weight: 600;
    font-size: 14px;
    color: #5a7ab8;
    cursor: pointer;
    transition: all 0.2s ease;
}

.mode-btn.active {
    background-color: #4a86e8;
    color: white;
}

.status-offline {
    font-size: 12px;
    font-weight: 600;
    color: #ff6b6b;
    padding: 4px 8px;
    border-radius: 12px;
    background-color: #ffeeee;
}

.status-online {
    font-size: 12px;
    font-weight: 600;
    color: #50c878;
    padding: 4px 8px;
    border-radius: 12px;
    background-color: #eeffee;
}

.users-count {
    font-size: 12px;
    font-weight: 600;
    color: #5a7ab8;
    padding: 4px 8px;
    border-radius: 12px;
    background-color: #f0f6ff;
}

.actions {
    display: flex;
    gap: 10px;
}

.btn {
    background-color: #e6f0ff;
    border: none;
    border-radius: 6px;
    padding: 8px 15px;
    font-family: 'Inter', sans-serif;
    font-weight: 600;
    font-size: 14px;
    color: #4a86e8;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 6px;
}

.btn:hover {
    background-color: #d1e3ff;
}

.btn i {
    font-size: 14px;
}

/* Toolbar Styles */
.toolbar {
    background-color: #ffffff;
    padding: 15px 25px;
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    border-bottom: 1px solid #e6f0ff;
}

.tool-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.tool {
    background-color: #f0f6ff;
    border-radius: 6px;
    padding: 8px 15px;
    font-size: 14px;
    font-weight: 600;
    color: #5a7ab8;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 6px;
}

.tool.active {
    background-color: #4a86e8;
    color: white;
}

.tool:hover:not(.active) {
    background-color: #e1ebff;
}

.tool i {
    font-size: 14px;
}

.tool-options {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
}

.size-option, .color-option, .font-option, .shape-option, .zoom-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.size-option label, .color-option label, .font-option label, .shape-option label {
    font-size: 14px;
    font-weight: 600;
    color: #5a7ab8;
}

#size-slider {
    width: 100px;
    accent-color: #4a86e8;
}

#size-value {
    font-size: 14px;
    color: #5a7ab8;
    width: 40px;
}

#color-picker {
    width: 30px;
    height: 30px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    padding: 0;
}

.color-presets {
    display: flex;
    gap: 5px;
}

.color-preset {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.color-preset:hover {
    transform: scale(1.2);
}

#font-select, #shape-select {
    padding: 5px 10px;
    border-radius: 4px;
    border: 1px solid #d1e3ff;
    background-color: #f0f6ff;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    color: #5a7ab8;
}

.zoom-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.zoom-btn {
    background-color: #f0f6ff;
    border: none;
    border-radius: 4px;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #5a7ab8;
    cursor: pointer;
    transition: all 0.2s ease;
}

.zoom-btn:hover {
    background-color: #e1ebff;
}

#zoom-level {
    font-size: 14px;
    font-weight: 600;
    color: #5a7ab8;
    width: 50px;
    text-align: center;
}

/* Canvas Styles */
.canvas-container {
    flex: 1;
    position: relative;
    background-color: #f0f6ff;
    overflow: hidden;
}

.canvas-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
    overflow: auto;
}

#whiteboard {
    position: absolute;
    top: 0;
    left: 0;
    cursor: crosshair;
    background-color: white;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

/* Text Input Styles */
.text-input-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    z-index: 100;
    width: 300px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#text-input {
    width: 100%;
    height: 100px;
    padding: 10px;
    border-radius: 4px;
    border: 1px solid #d1e3ff;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    resize: none;
}

#add-text-btn, #cancel-text-btn {
    padding: 8px;
    border: none;
    border-radius: 4px;
    font-family: 'Inter', sans-serif;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

#add-text-btn {
    background-color: #4a86e8;
    color: white;
}

#add-text-btn:hover {
    background-color: #3a76d8;
}

#cancel-text-btn {
    background-color: #f0f0f0;
    color: #666;
}

#cancel-text-btn:hover {
    background-color: #e0e0e0;
}

/* User Cursors */
#user-cursors {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 50;
}

.user-cursor {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

.user-cursor::after {
    content: attr(data-username);
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    margin-top: 5px;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    header {
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
    }
    
    .mode-toggle, .actions {
        width: 100%;
        justify-content: space-between;
    }
    
    .toolbar {
        flex-direction: column;
    }
    
    .tool-group, .tool-options {
        width: 100%;
    }
}
        
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">whiteflow</div>
            <div class="mode-toggle">
                <button id="solo-mode" class="mode-btn active">solo mode</button>
                <button id="collab-mode" class="mode-btn">online mode</button>
                <span id="online-status" class="status-offline">offline</span>
                <span id="users-count" class="users-count" style="display: none;">0 users</span>
            </div>
            <div class="actions">
                <button id="save-btn" class="btn"><i class="fas fa-save"></i> save</button>
                <button id="clear-btn" class="btn"><i class="fas fa-trash"></i> clear</button>
                <button id="undo-btn" class="btn"><i class="fas fa-undo"></i> undo</button>
            </div>
        </header>
        
        <div class="toolbar">
            <div class="tool-group">
                <div class="tool" data-tool="marker"><i class="fas fa-marker"></i> marker</div>
                <div class="tool" data-tool="pencil"><i class="fas fa-pencil-alt"></i> pencil</div>
                <div class="tool" data-tool="pen"><i class="fas fa-pen"></i> pen</div>
                <div class="tool" data-tool="eraser"><i class="fas fa-eraser"></i> eraser</div>
                <div class="tool" data-tool="text"><i class="fas fa-font"></i> text</div>
                <div class="tool" data-tool="shape"><i class="fas fa-shapes"></i> shapes</div>
            </div>
            
            <div class="tool-options">
                <div class="size-option">
                    <label for="size-slider">size:</label>
                    <input type="range" id="size-slider" min="1" max="50" value="5">
                    <span id="size-value">5px</span>
                </div>
                
                <div class="color-option">
                    <label for="color-picker">color:</label>
                    <input type="color" id="color-picker" value="#4a86e8">
                    <div class="color-presets">
                        <div class="color-preset" style="background-color: #4a86e8;"></div>
                        <div class="color-preset" style="background-color: #ff6b6b;"></div>
                        <div class="color-preset" style="background-color: #50c878;"></div>
                        <div class="color-preset" style="background-color: #ffd700;"></div>
                        <div class="color-preset" style="background-color: #9370db;"></div>
                        <div class="color-preset" style="background-color: #000000;"></div>
                    </div>
                </div>
                
                <div class="font-option" style="display: none;">
                    <label for="font-select">font:</label>
                    <select id="font-select">
                        <option value="Inter">inter</option>
                        <option value="Arial">arial</option>
                        <option value="Helvetica">helvetica</option>
                        <option value="Times New Roman">times new roman</option>
                        <option value="Courier New">courier new</option>
                    </select>
                </div>
                
                <div class="shape-option" style="display: none;">
                    <label for="shape-select">shape:</label>
                    <select id="shape-select">
                        <option value="rectangle">rectangle</option>
                        <option value="circle">circle</option>
                        <option value="line">line</option>
                        <option value="triangle">triangle</option>
                        <option value="arrow">arrow</option>
                    </select>
                </div>
                
                <div class="zoom-controls">
                    <button id="zoom-in" class="zoom-btn"><i class="fas fa-search-plus"></i></button>
                    <span id="zoom-level">100%</span>
                    <button id="zoom-out" class="zoom-btn"><i class="fas fa-search-minus"></i></button>
                    <button id="zoom-reset" class="zoom-btn"><i class="fas fa-compress-arrows-alt"></i></button>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="whiteboard"></canvas>
            </div>
        </div>
        
        <div class="text-input-container" style="display: none;">
            <textarea id="text-input" placeholder="enter text here..."></textarea>
            <button id="add-text-btn">add text</button>
            <button id="cancel-text-btn">cancel</button>
        </div>
        
        <div id="user-cursors"></div>
    </div>
    
    <script src="script.js"></script>

    <script>

        // canvas setup
const canvas = document.getElementById('whiteboard');
const ctx = canvas.getContext('2d');
const container = document.querySelector('.canvas-container');
const canvasWrapper = document.querySelector('.canvas-wrapper');

// socket.io setup for real-time collaboration
let socket;
let isOnlineMode = false;
let userId = generateUserId();
let userColor = getRandomColor();
let userCursors = {};

// drawing state variables
let isDrawing = false;
let lastX = 0;
let lastY = 0;
let currentTool = 'marker';
let currentColor = '#4a86e8';
let currentSize = 5;
let currentFont = 'Inter';
let currentShape = 'rectangle';
let drawingHistory = [];
let currentStep = -1;
let textPosition = { x: 0, y: 0 };
let shapeStartPosition = { x: 0, y: 0 };
let currentPath = []; // Store the current drawing path
let zoomLevel = 1;

// tool elements
const tools = document.querySelectorAll('.tool');
const sizeSlider = document.getElementById('size-slider');
const sizeValue = document.getElementById('size-value');
const colorPicker = document.getElementById('color-picker');
const colorPresets = document.querySelectorAll('.color-preset');
const fontSelect = document.getElementById('font-select');
const shapeSelect = document.getElementById('shape-select');
const fontOption = document.querySelector('.font-option');
const shapeOption = document.querySelector('.shape-option');
const textInputContainer = document.querySelector('.text-input-container');
const textInput = document.getElementById('text-input');
const addTextBtn = document.getElementById('add-text-btn');
const cancelTextBtn = document.getElementById('cancel-text-btn');

// action buttons
const saveBtn = document.getElementById('save-btn');
const clearBtn = document.getElementById('clear-btn');
const undoBtn = document.getElementById('undo-btn');

// mode buttons
const soloModeBtn = document.getElementById('solo-mode');
const collabModeBtn = document.getElementById('collab-mode');
const onlineStatus = document.getElementById('online-status');
const usersCount = document.getElementById('users-count');

// zoom controls
const zoomInBtn = document.getElementById('zoom-in');
const zoomOutBtn = document.getElementById('zoom-out');
const zoomResetBtn = document.getElementById('zoom-reset');
const zoomLevelDisplay = document.getElementById('zoom-level');

// resize canvas to fit container
function resizeCanvas() {
    // Set canvas size to a large fixed size for better drawing area
    canvas.width = 3000;
    canvas.height = 2000;
    
    // Center the canvas initially
    centerCanvas();
    
    // Redraw canvas content
    if (currentStep >= 0) {
        restoreState(currentStep);
    } else {
        initCanvas();
    }
}

// center the canvas in the viewport
function centerCanvas() {
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Position the canvas in the center
    canvasWrapper.scrollLeft = (canvas.width - containerWidth) / 2;
    canvasWrapper.scrollTop = (canvas.height - containerHeight) / 2;
}

// initialize canvas size
resizeCanvas();

// handle window resize
window.addEventListener('resize', () => {
    // No need to resize the canvas, just update the view
    updateZoomAndPan();
});

// apply zoom and pan transformations
function updateZoomAndPan() {
    canvasWrapper.style.transform = `scale(${zoomLevel})`;
    zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
}

// zoom controls
zoomInBtn.addEventListener('click', () => {
    if (zoomLevel < 3) {
        zoomLevel += 0.1;
        updateZoomAndPan();
    }
});

zoomOutBtn.addEventListener('click', () => {
    if (zoomLevel > 0.3) {
        zoomLevel -= 0.1;
        updateZoomAndPan();
    }
});

zoomResetBtn.addEventListener('click', () => {
    zoomLevel = 1;
    updateZoomAndPan();
    centerCanvas();
});

// save current canvas state to history
function saveState() {
    // limit history size to prevent memory issues
    if (currentStep < drawingHistory.length - 1) {
        drawingHistory.splice(currentStep + 1);
    }
    
    currentStep++;
    const state = canvas.toDataURL();
    drawingHistory.push(state);
    
    // enable/disable undo button
    undoBtn.disabled = currentStep <= 0;
}

// restore canvas to a specific state
function restoreState(step) {
    if (step < 0 || step >= drawingHistory.length) return;
    
    currentStep = step;
    const img = new Image();
    img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
    };
    img.src = drawingHistory[step];
    
    // enable/disable undo button
    undoBtn.disabled = currentStep <= 0;
}

// initialize canvas with a blank state
function initCanvas() {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    saveState();
}

// set up drawing styles based on current tool
function setupDrawingStyle() {
    ctx.strokeStyle = currentColor;
    ctx.fillStyle = currentColor;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Set different line widths based on the tool
    switch(currentTool) {
        case 'marker':
            ctx.lineWidth = currentSize * 1.5;
            ctx.globalAlpha = 0.6;
            break;
        case 'pencil':
            ctx.lineWidth = currentSize * 0.8;
            ctx.globalAlpha = 0.8;
            break;
        case 'pen':
            ctx.lineWidth = currentSize;
            ctx.globalAlpha = 1;
            break;
        case 'shape':
            ctx.lineWidth = currentSize;
            ctx.globalAlpha = 1;
            break;
        case 'eraser':
            ctx.lineWidth = currentSize * 2;
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#ffffff';
            break;
    }
}

// convert canvas coordinates to account for zoom and scroll
function getCanvasCoordinates(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;
    
    return { x, y };
}

// start drawing
function startDrawing(e) {
    const coords = getCanvasCoordinates(e.clientX, e.clientY);
    lastX = coords.x;
    lastY = coords.y;
    
    if (currentTool === 'text') {
        textPosition = { x: lastX, y: lastY };
        textInputContainer.style.display = 'flex';
        textInput.focus();
        return;
    }
    
    if (currentTool === 'shape') {
        shapeStartPosition = { x: lastX, y: lastY };
    }
    
    isDrawing = true;
    currentPath = []; // Start a new path
    
    // For free drawing tools, add the first point
    if (['marker', 'pencil', 'pen', 'eraser'].includes(currentTool)) {
        currentPath.push({ 
            x: lastX, 
            y: lastY, 
            tool: currentTool,
            color: currentTool === 'eraser' ? '#ffffff' : currentColor,
            size: currentSize
        });
    }
    
    // If online, emit the drawing start event
    if (isOnlineMode && socket) {
        socket.emit('drawing-start', {
            x: lastX,
            y: lastY,
            tool: currentTool,
            color: currentTool === 'eraser' ? '#ffffff' : currentColor,
            size: currentSize,
            userId: userId
        });
    }
}

// draw based on mouse movement
function draw(e) {
    if (!isDrawing) return;
    
    const coords = getCanvasCoordinates(e.clientX, e.clientY);
    const x = coords.x;
    const y = coords.y;
    
    setupDrawingStyle();
    
    switch(currentTool) {
        case 'marker':
        case 'pencil':
        case 'pen':
        case 'eraser':
            // Draw a smooth curve between points
            ctx.beginPath();
            
            if (currentPath.length > 0) {
                const lastPoint = currentPath[currentPath.length - 1];
                ctx.moveTo(lastPoint.x, lastPoint.y);
            } else {
                ctx.moveTo(lastX, lastY);
            }
            
            ctx.lineTo(x, y);
            ctx.stroke();
            
            // Add point to current path
            currentPath.push({ 
                x: x, 
                y: y, 
                tool: currentTool,
                color: currentTool === 'eraser' ? '#ffffff' : currentColor,
                size: currentSize
            });
            
            // If online, emit the drawing event
            if (isOnlineMode && socket) {
                socket.emit('drawing', {
                    x0: lastX,
                    y0: lastY,
                    x1: x,
                    y1: y,
                    tool: currentTool,
                    color: currentTool === 'eraser' ? '#ffffff' : currentColor,
                    size: currentSize,
                    userId: userId
                });
            }
            break;
            
        case 'shape':
            // For shape preview, we'll redraw from the saved state
            if (currentStep >= 0) {
                restoreState(currentStep);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            drawShape(shapeStartPosition.x, shapeStartPosition.y, x, y);
            break;
    }
    
    lastX = x;
    lastY = y;
}

// finish drawing
function endDrawing() {
    if (!isDrawing) return;
    
    if (currentTool === 'shape' && isDrawing) {
        // If online, emit the shape drawing event
        if (isOnlineMode && socket) {
            socket.emit('shape-drawn', {
                startX: shapeStartPosition.x,
                startY: shapeStartPosition.y,
                endX: lastX,
                endY: lastY,
                shapeType: currentShape,
                color: currentColor,
                size: currentSize,
                userId: userId
            });
        }
    }
    
    isDrawing = false;
    saveState();
    
    // If online, emit the drawing end event
    if (isOnlineMode && socket && currentPath.length > 0) {
        socket.emit('drawing-end', {
            path: currentPath,
            userId: userId
        });
    }
    
    currentPath = []; // Clear the current path
}

// draw different shapes
function drawShape(startX, startY, endX, endY) {
    setupDrawingStyle();
    
    switch(currentShape) {
        case 'rectangle':
            ctx.beginPath();
            ctx.rect(startX, startY, endX - startX, endY - startY);
            ctx.stroke();
            break;
        case 'circle':
            const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            ctx.beginPath();
            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
            ctx.stroke();
            break;
        case 'line':
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            break;
        case 'triangle':
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.lineTo(startX - (endX - startX), endY);
            ctx.closePath();
            ctx.stroke();
            break;
        case 'arrow':
            const angle = Math.atan2(endY - startY, endX - startX);
            const headLength = 15;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            break;
    }
}

// add text to canvas
function addTextToCanvas() {
    const text = textInput.value.trim();
    if (!text) return;
    
    // restore previous state before adding text
    if (currentStep >= 0) {
        restoreState(currentStep);
    }
    
    ctx.globalAlpha = 1;
    ctx.fillStyle = currentColor;
    ctx.font = `${currentSize * 2}px ${currentFont}`;
    ctx.fillText(text, textPosition.x, textPosition.y);
    
    // If online, emit the text added event
    if (isOnlineMode && socket) {
        socket.emit('text-added', {
            text: text,
            x: textPosition.x,
            y: textPosition.y,
            color: currentColor,
            size: currentSize,
            font: currentFont,
            userId: userId
        });
    }
    
    // save state after adding text
    saveState();
    
    // hide text input
    textInputContainer.style.display = 'none';
    textInput.value = '';
}

// draw on the canvas from remote user
function drawRemote(data) {
    const originalTool = currentTool;
    const originalColor = currentColor;
    const originalSize = currentSize;
    
    // Set the remote user's drawing style
    currentTool = data.tool;
    currentColor = data.color;
    currentSize = data.size;
    
    setupDrawingStyle();
    
    ctx.beginPath();
    ctx.moveTo(data.x0, data.y0);
    ctx.lineTo(data.x1, data.y1);
    ctx.stroke();
    
    // Restore original settings
    currentTool = originalTool;
    currentColor = originalColor;
    currentSize = originalSize;
}

// draw shape from remote user
function drawRemoteShape(data) {
    const originalColor = currentColor;
    const originalSize = currentSize;
    
    // Set the remote user's drawing style
    currentColor = data.color;
    currentSize = data.size;
    
    setupDrawingStyle();
    
    drawShape(data.startX, data.startY, data.endX, data.endY);
    
    // Restore original settings
    currentColor = originalColor;
    currentSize = originalSize;
}

// add text from remote user
function addRemoteText(data) {
    ctx.globalAlpha = 1;
    ctx.fillStyle = data.color;
    ctx.font = `${data.size * 2}px ${data.font}`;
    ctx.fillText(data.text, data.x, data.y);
}

// update remote user cursor position
function updateRemoteCursor(data) {
    let cursorElement = document.getElementById(`cursor-${data.userId}`);
    
    if (!cursorElement) {
        cursorElement = document.createElement('div');
        cursorElement.id = `cursor-${data.userId}`;
        cursorElement.className = 'user-cursor';
        cursorElement.style.backgroundColor = data.color;
        cursorElement.setAttribute('data-username', `user-${data.userId.substring(0, 4)}`);
        document.getElementById('user-cursors').appendChild(cursorElement);
    }
    
    // Position the cursor
    cursorElement.style.left = `${data.x}px`;
    cursorElement.style.top = `${data.y}px`;
}

// remove remote user cursor
function removeRemoteCursor(userId) {
    const cursorElement = document.getElementById(`cursor-${userId}`);
    if (cursorElement) {
        cursorElement.remove();
    }
}

// connect to socket.io server for real-time collaboration
function connectToServer() {
    // In a real implementation, you would connect to your actual server
    // For this demo, we'll simulate the socket.io connection
    console.log('Connecting to server...');
    
    // Simulate connection success
    setTimeout(() => {
        isOnlineMode = true;
        onlineStatus.textContent = 'online';
        onlineStatus.className = 'status-online';
        usersCount.style.display = 'inline';
        usersCount.textContent = '1 user';
        
        // Simulate other users joining
        simulateCollaboration();
    }, 1000);
}

// disconnect from socket.io server
function disconnectFromServer() {
    console.log('Disconnecting from server...');
    
    // Clear all remote cursors
    document.getElementById('user-cursors').innerHTML = '';
    
    // Reset status
    isOnlineMode = false;
    onlineStatus.textContent = 'offline';
    onlineStatus.className = 'status-offline';
    usersCount.style.display = 'none';
    
    // Stop simulation
    clearInterval(simulationInterval);
}

// simulate collaboration for demo purposes
let simulationInterval;
function simulateCollaboration() {
    // Simulate users count changing
    setTimeout(() => {
        usersCount.textContent = '2 users';
    }, 3000);
    
    setTimeout(() => {
        usersCount.textContent = '3 users';
    }, 6000);
    
    // Simulate remote cursor movements
    const remoteUserId = 'remote-user-1';
    const remoteColor = getRandomColor();
    
    simulationInterval = setInterval(() => {
        if (!isOnlineMode) return;
        
        // Simulate cursor movement
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        
        updateRemoteCursor({
            userId: remoteUserId,
            x: x,
            y: y,
            color: remoteColor
        });
    }, 2000);
}

// event listeners for drawing
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', endDrawing);
canvas.addEventListener('mouseout', endDrawing);

// event listeners for touch devices
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const mouseEvent = new MouseEvent('mouseup', {});
    canvas.dispatchEvent(mouseEvent);
});

// track cursor position for online mode
canvas.addEventListener('mousemove', (e) => {
    if (isOnlineMode && socket) {
        const coords = getCanvasCoordinates(e.clientX, e.clientY);
        socket.emit('cursor-move', {
            x: coords.x,
            y: coords.y,
            userId: userId,
            color: userColor
        });
    }
});

// tool selection
tools.forEach(tool => {
    tool.addEventListener('click', () => {
        // remove active class from all tools
        tools.forEach(t => t.classList.remove('active'));
        
        // add active class to selected tool
        tool.classList.add('active');
        
        // update current tool
        currentTool = tool.dataset.tool;
        
        // show/hide tool-specific options
        if (currentTool === 'text') {
            fontOption.style.display = 'flex';
            shapeOption.style.display = 'none';
        } else if (currentTool === 'shape') {
            fontOption.style.display = 'none';
            shapeOption.style.display = 'flex';
        } else {
            fontOption.style.display = 'none';
            shapeOption.style.display = 'none';
        }
    });
});

// set marker as default active tool
document.querySelector('[data-tool="marker"]').classList.add('active');

// size slider
sizeSlider.addEventListener('input', () => {
    currentSize = parseInt(sizeSlider.value);
    sizeValue.textContent = `${currentSize}px`;
});

// color picker
colorPicker.addEventListener('input', () => {
    currentColor = colorPicker.value;
});

// color presets
colorPresets.forEach(preset => {
    preset.addEventListener('click', () => {
        const color = getComputedStyle(preset).backgroundColor;
        currentColor = rgbToHex(color);
        colorPicker.value = currentColor;
    });
});

// font selection
fontSelect.addEventListener('change', () => {
    currentFont = fontSelect.value;
});

// shape selection
shapeSelect.addEventListener('change', () => {
    currentShape = shapeSelect.value;
});

// text input buttons
addTextBtn.addEventListener('click', addTextToCanvas);
cancelTextBtn.addEventListener('click', () => {
    textInputContainer.style.display = 'none';
    textInput.value = '';
});

// save button
saveBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'whiteflow-drawing.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
});

// clear button
clearBtn.addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    saveState();
    
    // If online, emit the clear event
    if (isOnlineMode && socket) {
        socket.emit('canvas-cleared', {
            userId: userId
        });
    }
});

// undo button
undoBtn.addEventListener('click', () => {
    if (currentStep > 0) {
        restoreState(currentStep - 1);
        
        // If online, emit the undo event
        if (isOnlineMode && socket) {
            socket.emit('canvas-state-changed', {
                stateData: drawingHistory[currentStep],
                userId: userId
            });
        }
    }
});

// mode toggle buttons
soloModeBtn.addEventListener('click', () => {
    if (isOnlineMode) {
        disconnectFromServer();
    }
    
    soloModeBtn.classList.add('active');
    collabModeBtn.classList.remove('active');
});

collabModeBtn.addEventListener('click', () => {
    if (!isOnlineMode) {
        connectToServer();
    }
    
    collabModeBtn.classList.add('active');
    soloModeBtn.classList.remove('active');
});

// helper function to convert rgb to hex
function rgbToHex(rgb) {
    // extract rgb values
    const rgbValues = rgb.match(/\d+/g);
    if (!rgbValues || rgbValues.length < 3) return '#000000';
    
    // convert to hex
    const r = parseInt(rgbValues[0]);
    const g = parseInt(rgbValues[1]);
    const b = parseInt(rgbValues[2]);
    
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// helper function to generate a random user ID
function generateUserId() {
    return 'user-' + Math.random().toString(36).substring(2, 10);
}

// helper function to get a random color
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// initialize canvas
initCanvas();

// disable undo button initially
undoBtn.disabled = true;

// create server.js file for real implementation
// Note: This is just a placeholder for a real server implementation
// In a real project, you would need to set up a Node.js server with Socket.io
/*
const express = require('express');
const http = require('http');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIO(server);

app.use(express.static('public'));

const users = {};

io.on('connection', (socket) => {
    console.log('New user connected');
    
    // Add user to the list
    users[socket.id] = {
        id: socket.id,
        color: getRandomColor()
    };
    
    // Broadcast updated user count
    io.emit('users-count', Object.keys(users).length);
    
    // Handle drawing events
    socket.on('drawing-start', (data) => {
        socket.broadcast.emit('drawing-start', data);
    });
    
    socket.on('drawing', (data) => {
        socket.broadcast.emit('drawing', data);
    });
    
    socket.on('drawing-end', (data) => {
        socket.broadcast.emit('drawing-end', data);
    });
    
    socket.on('shape-drawn', (data) => {
        socket.broadcast.emit('shape-drawn', data);
    });
    
    socket.on('text-added', (data) => {
        socket.broadcast.emit('text-added', data);
    });
    
    socket.on('cursor-move', (data) => {
        socket.broadcast.emit('cursor-move', data);
    });
    
    socket.on('canvas-cleared', (data) => {
        socket.broadcast.emit('canvas-cleared', data);
    });
    
    socket.on('canvas-state-changed', (data) => {
        socket.broadcast.emit('canvas-state-changed', data);
    });
    
    socket.on('disconnect', () => {
        console.log('User disconnected');
        
        // Remove user from the list
        delete users[socket.id];
        
        // Broadcast updated user count
        io.emit('users-count', Object.keys(users).length);
        
        // Broadcast user disconnection to remove cursor
        io.emit('user-disconnected', socket.id);
    });
});

function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
*/
        
    </script>
</body>
</html>
